# 🔐 Security & Authentication

> **Enterprise-grade security: JWT, API Keys, Rate Limiting, 2FA**

[◀️ Geri: i18n & Localization](07_i18n_Localization.md) | [Ana Sayfa](README.md) | [İleri: Implementation Checklist ▶️](09_Implementation_Checklist.md)

---

## 📋 İçindekiler

1. [Authentication Methods](#authentication-methods)
2. [3-Level API Keys](#3-level-api-keys)
3. [JWT Tokens](#jwt-tokens)
4. [Rate Limiting](#rate-limiting)
5. [2FA Support](#2fa-support)
6. [Security Best Practices](#security-best-practices)

---

## Authentication Methods

### 3 Authentication Yöntemi

| Method | Use Case | Expiry | Revocable |
|--------|----------|--------|-----------|
| **JWT Token** | User login (frontend) | 7 days | ❌ No (stateless) |
| **API Key** | Server-to-server | Never | ✅ Yes |
| **Session** | Web app (cookie) | 30 days | ✅ Yes |

---

## 3-Level API Keys

### API Key Types

| Type | Prefix | Use Case | Permissions |
|------|--------|----------|-------------|
| **Live** | `hzm_live_` | Production | Full access |
| **Test** | `hzm_test_` | Development | Test data only |
| **Restricted** | `hzm_restr_` | Limited access | Custom scopes |

### API Key Structure

```
hzm_live_AbCdEfGh123456789XyZ...
│   │     └─────────────────────── Random 32 chars
│   └──────────────────────────────── Environment (live/test/restr)
└──────────────────────────────────── Vendor prefix (hzm)
```

### Database Schema

```sql
CREATE TABLE core.api_keys (
  id GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tenant_id INTEGER NOT NULL REFERENCES core.tenants(id),
  user_id INTEGER NOT NULL REFERENCES core.users(id),
  
  -- Key Info
  name VARCHAR(100) NOT NULL,
  key_prefix VARCHAR(20) UNIQUE NOT NULL,  -- 'hzm_live_abc...'
  key_hash VARCHAR(255) NOT NULL,          -- SHA-256 hash
  key_encrypted TEXT NOT NULL,             -- Encrypted full key
  
  -- Permissions
  permissions JSONB DEFAULT '{}'::jsonb,
  scopes TEXT[] DEFAULT '{}',
  
  -- Rate Limiting
  rate_limit_per_minute INTEGER DEFAULT 60,
  rate_limit_per_day INTEGER DEFAULT 10000,
  
  -- IP Restrictions
  allowed_ips TEXT[] DEFAULT '{}',
  allowed_domains TEXT[] DEFAULT '{}',
  
  -- Usage Tracking
  last_used_at TIMESTAMPTZ,
  total_requests BIGINT DEFAULT 0,
  total_errors INTEGER DEFAULT 0,
  
  -- Lifecycle
  expires_at TIMESTAMPTZ,
  is_active BOOLEAN DEFAULT TRUE,
  revoked_at TIMESTAMPTZ,
  revoked_by INTEGER,
  
  created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);
```

### API Key Generation

```javascript
// services/apiKeyService.js
const crypto = require('crypto');

class APIKeyService {
  /**
   * API key oluştur
   */
  async generateAPIKey(userId, name, type = 'live') {
    // Generate random key
    const randomBytes = crypto.randomBytes(32).toString('hex');
    const prefix = `hzm_${type}_`;
    const fullKey = `${prefix}${randomBytes}`;
    
    // Hash for database storage
    const hash = crypto.createHash('sha256').update(fullKey).digest('hex');
    
    // Encrypt for backup
    const encrypted = this.encrypt(fullKey);
    
    // Save to database
    await this.pool.query(`
      INSERT INTO core.api_keys 
        (tenant_id, user_id, name, key_prefix, key_hash, key_encrypted)
      VALUES ($1, $2, $3, $4, $5, $6)
    `, [tenantId, userId, name, prefix, hash, encrypted]);
    
    // Return key ONCE (never show again!)
    return fullKey;
  }
  
  /**
   * API key doğrula
   */
  async validateAPIKey(apiKey) {
    const hash = crypto.createHash('sha256').update(apiKey).digest('hex');
    
    const result = await this.pool.query(`
      SELECT * FROM core.api_keys
      WHERE key_hash = $1 
        AND is_active = TRUE 
        AND (expires_at IS NULL OR expires_at > CURRENT_TIMESTAMP)
        AND revoked_at IS NULL
    `, [hash]);
    
    if (!result.rows[0]) {
      throw new Error('Invalid API key');
    }
    
    // Update last_used_at
    await this.pool.query(`
      UPDATE core.api_keys 
      SET last_used_at = CURRENT_TIMESTAMP, 
          total_requests = total_requests + 1
      WHERE id = $1
    `, [result.rows[0].id]);
    
    return result.rows[0];
  }
}
```

### API Key Middleware

```javascript
// middleware/apiKeyAuth.js
async function apiKeyAuth(req, res, next) {
  try {
    const apiKey = req.headers['x-api-key'];
    
    if (!apiKey) {
      return res.status(401).json({ error: 'API key required' });
    }
    
    // Validate key
    const keyData = await apiKeyService.validateAPIKey(apiKey);
    
    // Check rate limit
    const rateLimit = await rateLimiter.check(keyData.id);
    if (rateLimit.exceeded) {
      return res.status(429).json({ 
        error: 'Rate limit exceeded',
        retry_after: rateLimit.retry_after
      });
    }
    
    // Check IP whitelist
    if (keyData.allowed_ips.length > 0) {
      const clientIP = req.ip;
      if (!keyData.allowed_ips.includes(clientIP)) {
        return res.status(403).json({ error: 'IP not allowed' });
      }
    }
    
    // Check scopes
    if (!hasRequiredScope(keyData.scopes, req.path, req.method)) {
      return res.status(403).json({ error: 'Insufficient permissions' });
    }
    
    // Set context
    req.api_key = keyData;
    req.tenant_id = keyData.tenant_id;
    req.user_id = keyData.user_id;
    
    next();
  } catch (error) {
    return res.status(401).json({ error: error.message });
  }
}
```

---

## JWT Tokens

### Token Structure

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
│                                   │                                                                                                             │
Header                              Payload                                                                                                      Signature
```

### Payload

```json
{
  "user_id": 123,
  "tenant_id": 10,
  "email": "user@example.com",
  "role": "admin",
  "iat": 1729512000,  // Issued at
  "exp": 1730116800   // Expires at (7 days)
}
```

### JWT Service

```javascript
// services/jwtService.js
const jwt = require('jsonwebtoken');

class JWTService {
  /**
   * JWT token oluştur
   */
  generateToken(user) {
    const payload = {
      user_id: user.id,
      tenant_id: user.tenant_id,
      email: user.email,
      role: user.role
    };
    
    return jwt.sign(payload, process.env.JWT_SECRET, {
      expiresIn: '7d'  // 7 days
    });
  }
  
  /**
   * JWT token doğrula
   */
  verifyToken(token) {
    try {
      return jwt.verify(token, process.env.JWT_SECRET);
    } catch (error) {
      if (error.name === 'TokenExpiredError') {
        throw new Error('Token expired');
      }
      throw new Error('Invalid token');
    }
  }
  
  /**
   * Refresh token oluştur
   */
  generateRefreshToken(userId) {
    const payload = { user_id: userId, type: 'refresh' };
    
    return jwt.sign(payload, process.env.JWT_REFRESH_SECRET, {
      expiresIn: '30d'  // 30 days
    });
  }
}
```

### JWT Middleware

```javascript
// middleware/jwtAuth.js
async function jwtAuth(req, res, next) {
  try {
    const authHeader = req.headers['authorization'];
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'Token required' });
    }
    
    const token = authHeader.substring(7);
    const decoded = jwtService.verifyToken(token);
    
    // Get user
    const user = await getUserById(decoded.user_id);
    
    if (!user || !user.is_active) {
      return res.status(401).json({ error: 'User not found or inactive' });
    }
    
    // Set context
    req.user = user;
    req.tenant_id = user.tenant_id;
    
    next();
  } catch (error) {
    return res.status(401).json({ error: error.message });
  }
}
```

---

## Rate Limiting

### Tenant-Based Rate Limiting

```javascript
// services/rateLimiter.js
const Redis = require('ioredis');
const redis = new Redis(process.env.REDIS_URL);

class RateLimiter {
  /**
   * Rate limit kontrolü
   */
  async check(tenantId, identifier, limits = {}) {
    const { perMinute = 60, perDay = 10000 } = limits;
    
    // Keys
    const minuteKey = `ratelimit:${tenantId}:${identifier}:minute`;
    const dayKey = `ratelimit:${tenantId}:${identifier}:day`;
    
    // Increment counters
    const [minuteCount, dayCount] = await Promise.all([
      this.increment(minuteKey, 60),    // 60 seconds TTL
      this.increment(dayKey, 86400)     // 24 hours TTL
    ]);
    
    // Check limits
    if (minuteCount > perMinute) {
      return {
        exceeded: true,
        reason: 'per_minute',
        limit: perMinute,
        current: minuteCount,
        retry_after: await redis.ttl(minuteKey)
      };
    }
    
    if (dayCount > perDay) {
      return {
        exceeded: true,
        reason: 'per_day',
        limit: perDay,
        current: dayCount,
        retry_after: await redis.ttl(dayKey)
      };
    }
    
    return {
      exceeded: false,
      remaining_minute: perMinute - minuteCount,
      remaining_day: perDay - dayCount
    };
  }
  
  /**
   * Counter increment (Redis)
   */
  async increment(key, ttl) {
    const count = await redis.incr(key);
    if (count === 1) {
      await redis.expire(key, ttl);
    }
    return count;
  }
}
```

### Rate Limit Middleware

```javascript
// middleware/rateLimit.js
async function rateLimit(req, res, next) {
  const tenantId = req.tenant_id;
  const identifier = req.api_key?.id || req.user?.id || req.ip;
  
  const limits = {
    perMinute: req.api_key?.rate_limit_per_minute || 60,
    perDay: req.api_key?.rate_limit_per_day || 10000
  };
  
  const result = await rateLimiter.check(tenantId, identifier, limits);
  
  // Set headers
  res.setHeader('X-RateLimit-Limit', limits.perMinute);
  res.setHeader('X-RateLimit-Remaining', result.remaining_minute || 0);
  
  if (result.exceeded) {
    res.setHeader('Retry-After', result.retry_after);
    return res.status(429).json({
      error: 'Rate limit exceeded',
      reason: result.reason,
      retry_after: result.retry_after
    });
  }
  
  next();
}
```

---

## 2FA Support

### 2FA Methods

| Method | Delivery | Security | UX |
|--------|----------|----------|-----|
| **TOTP** | Authenticator app | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| **SMS** | Text message | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **Email** | Email code | ⭐⭐ | ⭐⭐⭐⭐ |

### Database Schema

```sql
CREATE TABLE core.user_2fa (
  id GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tenant_id INTEGER NOT NULL REFERENCES core.tenants(id),
  user_id INTEGER UNIQUE REFERENCES core.users(id),
  
  method VARCHAR(20) NOT NULL,  -- 'totp', 'sms', 'email'
  secret_encrypted TEXT NOT NULL,
  backup_codes_encrypted TEXT[],
  
  is_enabled BOOLEAN DEFAULT FALSE,
  enabled_at TIMESTAMPTZ,
  last_used_at TIMESTAMPTZ,
  
  created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);
```

### TOTP Implementation

```javascript
// services/totpService.js
const speakeasy = require('speakeasy');
const QRCode = require('qrcode');

class TOTPService {
  /**
   * TOTP secret oluştur
   */
  async generateSecret(user) {
    const secret = speakeasy.generateSecret({
      name: `HZM Platform (${user.email})`,
      issuer: 'HZM Platform'
    });
    
    // Generate QR code
    const qrCode = await QRCode.toDataURL(secret.otpauth_url);
    
    // Encrypt & save
    await this.saveSecret(user.id, secret.base32);
    
    return {
      secret: secret.base32,
      qr_code: qrCode
    };
  }
  
  /**
   * TOTP code doğrula
   */
  verifyCode(secret, code) {
    return speakeasy.totp.verify({
      secret,
      encoding: 'base32',
      token: code,
      window: 1  // Allow 30s clock drift
    });
  }
}
```

---

## Security Best Practices

### ✅ DO

1. **Hash passwords** - bcrypt or argon2
2. **HTTPS only** - No plain HTTP
3. **Rate limiting** - Prevent brute force
4. **IP whitelist** - For sensitive operations
5. **Audit logs** - Track all changes
6. **2FA** - For admin accounts
7. **API key rotation** - Regular rotation
8. **JWT expiry** - Short-lived tokens
9. **CORS** - Strict CORS policy
10. **SQL injection** - Use parameterized queries

### ❌ DON'T

1. **Plain text passwords** - Always hash!
2. **Long JWT expiry** - Max 7 days
3. **Expose secrets** - No secrets in code
4. **Trust user input** - Always validate
5. **Skip rate limiting** - DDoS risk
6. **Ignore audit logs** - GDPR requirement
7. **Use MD5/SHA1** - Weak algorithms
8. **Allow weak passwords** - Min 8 chars, complexity
9. **Skip HTTPS** - Man-in-the-middle risk
10. **Hardcode API keys** - Use environment variables

---

## 🔗 İlgili Dökümanlar

- [02_Core_Database_Schema.md](02_Core_Database_Schema.md) - core.api_keys, core.user_2fa
- [04_RLS_Multi_Tenant_Strategy.md](04_RLS_Multi_Tenant_Strategy.md) - Security through RLS
- [09_Implementation_Checklist.md](09_Implementation_Checklist.md) - P0 security features

---

**[◀️ Geri: i18n & Localization](07_i18n_Localization.md) | [Ana Sayfa](README.md) | [İleri: Implementation Checklist ▶️](09_Implementation_Checklist.md)**

