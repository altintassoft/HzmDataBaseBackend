# ğŸš¨ Common Mistakes

> **9 kritik hata & Ã§Ã¶zÃ¼mleri - GerÃ§ek projelerden Ã¶ÄŸrenilen dersler**

[â—€ï¸ Geri: Implementation Checklist](09_Implementation_Checklist.md) | [Ana Sayfa](README.md) | [Ä°leri: Roadmap & Tech Stack â–¶ï¸](11_Roadmap_TechStack.md)

---

## ğŸ“‹ Ä°Ã§indekiler

1. [9 Kritik Hata](#9-kritik-hata)
2. [GerÃ§ek Projelerden Ã–ÄŸrenilen Dersler](#gerÃ§ek-projelerden-Ã¶ÄŸrenilen-dersler)
3. [BaÅŸarÄ± Kriterleri](#baÅŸarÄ±-kriterleri)
4. [3 AltÄ±n Kural](#3-altÄ±n-kural)

---

## 9 Kritik Hata

### 1. RLS Yok (En Kritik Hata!) ğŸ”´

#### âŒ YANLIÅ

```sql
CREATE TABLE products (
  id SERIAL PRIMARY KEY,
  tenant_id INTEGER NOT NULL,
  name VARCHAR(200)
);

-- Developer kodu:
SELECT * FROM products WHERE tenant_id = $1;  -- Developer'a baÄŸlÄ±!
```

**Sorun:**
- Developer unutursa `WHERE tenant_id = $1` â†’ TÃ¼m tenant'larÄ±n verileri leak olur!
- SQL injection risk
- Junior developer hata yapabilir

#### âœ… DOÄRU

```sql
CREATE TABLE products (
  id GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tenant_id INTEGER NOT NULL REFERENCES core.tenants(id),
  name VARCHAR(200)
);

-- RLS aktif et
ALTER TABLE products ENABLE ROW LEVEL SECURITY;

-- RLS policy
CREATE POLICY rls_products_tenant ON products
  USING (tenant_id = app.current_tenant())
  WITH CHECK (tenant_id = app.current_tenant());

-- Developer kodu:
SELECT * FROM products;  -- RLS otomatik tenant_id = X ekler!
```

**Ã‡Ã¶zÃ¼m:**
- âœ… Database-level gÃ¼venlik
- âœ… UnutulmasÄ± imkansÄ±z
- âœ… Her query'de otomatik Ã§alÄ±ÅŸÄ±r

**GerÃ§ek Senaryo:**
```
Bir SaaS ÅŸirketi RLS kullanmÄ±yordu. 
Junior developer WHERE tenant_id = $1 yazmayÄ± unuttu.
1 tenant'Ä±n verileri tÃ¼m tenant'lara gitti.
Yasal dava, $2M ceza.
```

---

### 2. tenant_id Eksik ğŸ”´

#### âŒ YANLIÅ

```sql
CREATE TABLE products (
  id SERIAL PRIMARY KEY,
  name VARCHAR(200),
  price DECIMAL(10,2)
);
```

**Sorun:**
- Multi-tenant yapÄ± yok
- Sonradan eklemek 48 saat migration
- 1M kayÄ±tta production down

#### âœ… DOÄRU

```sql
CREATE TABLE products (
  id GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tenant_id INTEGER NOT NULL REFERENCES core.tenants(id),  -- ğŸ”¥ MUTLAKA!
  name VARCHAR(200),
  price DECIMAL(10,2)
);

-- Index
CREATE INDEX idx_products_tenant ON products(tenant_id);
```

**Ã‡Ã¶zÃ¼m:**
- âœ… Her tabloda `tenant_id`
- âœ… Her query'de `WHERE tenant_id = X`
- âœ… Index ile performans

**GerÃ§ek Senaryo:**
```
Startup 100K kullanÄ±cÄ±yla bÃ¼yÃ¼dÃ¼.
Multi-tenant olmaya karar verdi.
3 ay migration, mÃ¼ÅŸteri kaybÄ±, $500K maliyet.
```

---

### 3. SERIAL yerine GENERATED BY DEFAULT AS IDENTITY ğŸŸ¡

#### âŒ YANLIÅ (Eski PostgreSQL)

```sql
id SERIAL PRIMARY KEY
```

**Sorun:**
- Eski syntax (PostgreSQL 9.x)
- Sequence ownership karmaÅŸÄ±k
- Modern PostgreSQL desteÄŸi yok

#### âœ… DOÄRU (Modern PostgreSQL 10+)

```sql
id GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY  -- ğŸ”¥
```

**Farklar:**

| Ã–zellik | SERIAL | IDENTITY |
|---------|--------|----------|
| PostgreSQL | 7.x+ | 10+ |
| Standard SQL | âŒ | âœ… |
| Sequence ownership | Manual | Otomatik |
| TRUNCATE ... RESTART | âš ï¸ Complex | âœ… Kolay |
| Explicit insert | âœ… Ä°zin verir | âœ… Ä°zin verir |

**Ã–rnek:**

```sql
-- SERIAL
CREATE TABLE users (id SERIAL PRIMARY KEY);
-- Arka planda: CREATE SEQUENCE users_id_seq; ALTER TABLE users ALTER id SET DEFAULT nextval('users_id_seq');

-- IDENTITY
CREATE TABLE users (id GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY);
-- SQL Standard, daha temiz!
```

---

### 4. VARCHAR yerine citext (email iÃ§in) ğŸŸ¡

#### âŒ YANLIÅ

```sql
email VARCHAR(255) UNIQUE NOT NULL
```

**Sorun:**
- `user@test.com` â‰  `USER@TEST.COM`
- AynÄ± email 2 defa kayÄ±t olabilir
- Duplicate user accounts

#### âœ… DOÄRU

```sql
email citext UNIQUE NOT NULL  -- ğŸ”¥ Case-insensitive!
```

**Fark:**

```sql
-- VARCHAR ile:
SELECT * FROM users WHERE email = 'user@test.com';  -- 1 sonuÃ§
SELECT * FROM users WHERE email = 'USER@TEST.COM';  -- 0 sonuÃ§

-- citext ile:
SELECT * FROM users WHERE email = 'user@test.com';  -- 1 sonuÃ§
SELECT * FROM users WHERE email = 'USER@TEST.COM';  -- 1 sonuÃ§ (aynÄ±!)
```

**GerÃ§ek Senaryo:**
```
E-ticaret sitesi VARCHAR kullanÄ±yordu.
KullanÄ±cÄ± user@test.com ile kayÄ±t oldu.
Sonra USER@TEST.COM ile tekrar kayÄ±t oldu.
2 hesap, 1 email â†’ support nightmare.
```

---

### 5. TIMESTAMP yerine TIMESTAMPTZ ğŸ”´

#### âŒ YANLIÅ

```sql
created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
```

**Sorun:**
- Timezone bilgisi yok!
- YurtdÄ±ÅŸÄ± expansion'da sorun
- DST (Daylight Saving Time) bug'larÄ±

#### âœ… DOÄRU

```sql
created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP  -- ğŸ”¥
```

**Fark:**

```sql
-- TIMESTAMP (timezone yok)
INSERT INTO logs (created_at) VALUES ('2025-01-15 10:00:00');
-- Hangi timezone? New York? Tokyo? Bilinmiyor!

-- TIMESTAMPTZ (timezone var)
INSERT INTO logs (created_at) VALUES ('2025-01-15 10:00:00+03');
-- Kesin: Ä°stanbul zamanÄ±!
```

**Ã–rnek Senaryo:**

```
ABD'de kurulan startup TÃ¼rkiye'ye expand etti.
TIMESTAMP kullanÄ±yorlar.
created_at = '2025-01-15 10:00:00'  -- Hangi timezone?
3 saat fark support tickets'da kaos.
```

---

### 6. Soft Delete Eksik ğŸ”´

#### âŒ YANLIÅ

```sql
DELETE FROM products WHERE id = $1;
-- Veri gitti, geri gelmez!
```

**Sorun:**
- Kazara silme â†’ veri kaybÄ±
- "YanlÄ±ÅŸ sildim, geri getirebilir misin?" â†’ HayÄ±r!
- GDPR/KVKK compliance yok

#### âœ… DOÄRU

```sql
-- Soft delete columns
is_deleted BOOLEAN DEFAULT FALSE,
deleted_at TIMESTAMPTZ,
deleted_by INTEGER,

-- Soft delete trigger
CREATE TRIGGER trg_products_softdel 
  BEFORE DELETE ON products 
  FOR EACH ROW EXECUTE FUNCTION app.soft_delete();

-- Developer kodu:
DELETE FROM products WHERE id = $1;  -- Trigger otomatik UPDATE'e Ã§evirir!
```

**Soft Delete Function:**

```sql
CREATE OR REPLACE FUNCTION app.soft_delete()
RETURNS trigger LANGUAGE plpgsql AS $$
DECLARE 
  v_user int := app.current_user_id();
BEGIN
  EXECUTE format(
    'UPDATE %I.%I SET is_deleted = true, deleted_at = now(), deleted_by = $1 WHERE id = $2',
    TG_TABLE_SCHEMA, TG_TABLE_NAME
  ) USING v_user, OLD.id;
  RETURN NULL;  -- Cancel physical delete
END$$;
```

**GerÃ§ek Senaryo:**
```
E-ticaret sitesi 10K Ã¼rÃ¼nÃ¼ yanlÄ±ÅŸlÄ±kla sildi.
Backup yoktu.
24 saat sÃ¼ren data recovery, mÃ¼ÅŸteri kaybÄ±.
Soft delete olsaydÄ±: 1 dakikada geri getirirlerdi.
```

---

### 7. Index Eksik ğŸŸ¡

#### âŒ YANLIÅ

```sql
-- Index yok!
SELECT * FROM products WHERE tenant_id = $1;  -- Full table scan! (YavaÅŸ!)
```

**Sorun:**
- 1M kayÄ±tta her query saniyeler alÄ±r
- Production'da timeout
- CPU %100

#### âœ… DOÄRU

```sql
-- Index ekle
CREATE INDEX idx_products_tenant ON products(tenant_id);  -- ğŸ”¥

-- ArtÄ±k hÄ±zlÄ±:
SELECT * FROM products WHERE tenant_id = $1;  -- Index scan (Milliseconds!)
```

**Hangi Index'ler Zorunlu:**

```sql
-- 1. tenant_id (her tabloda!)
CREATE INDEX idx_{table}_tenant ON {table}(tenant_id);

-- 2. Foreign keys
CREATE INDEX idx_{table}_{fk} ON {table}(user_id);

-- 3. SÄ±k aranan kolonlar
CREATE INDEX idx_{table}_active ON {table}(tenant_id) 
  WHERE is_active = TRUE AND is_deleted = FALSE;

-- 4. Composite index (birlikte arananlar)
CREATE INDEX idx_{table}_composite ON {table}(tenant_id, status, created_at);
```

**Performans FarkÄ±:**

```
-- Index yok: 1M kayÄ±t, 5.2 saniye
-- Index var:  1M kayÄ±t, 12 millisecond

426x daha hÄ±zlÄ±!
```

---

### 8. Trigger'lar Eksik ğŸŸ¡

#### âŒ YANLIÅ

```sql
-- Her UPDATE'te manuel updated_at:
UPDATE products 
SET name = 'New Name', updated_at = now(), version = version + 1 
WHERE id = $1;

-- Developer unutabilir!
```

**Sorun:**
- `updated_at` unutulursa yanlÄ±ÅŸ timestamp
- `version` unutulursa race condition
- Manuel = error-prone

#### âœ… DOÄRU

```sql
-- Trigger ekle
CREATE TRIGGER trg_products_touch 
  BEFORE UPDATE ON products 
  FOR EACH ROW EXECUTE FUNCTION app.touch_row();

-- Developer kodu:
UPDATE products SET name = 'New Name' WHERE id = $1;
-- updated_at ve version otomatik artar!
```

**Touch Row Function:**

```sql
CREATE OR REPLACE FUNCTION app.touch_row()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  NEW.updated_at := now();
  IF TG_OP = 'UPDATE' THEN
    NEW.version := COALESCE(OLD.version, 1) + 1;  -- Optimistic locking
  END IF;
  RETURN NEW;
END$$;
```

**Standard 3 Trigger:**

```sql
-- 1. Updated_at + version
CREATE TRIGGER trg_{table}_touch 
  BEFORE UPDATE ON {table} 
  FOR EACH ROW EXECUTE FUNCTION app.touch_row();

-- 2. Soft delete
CREATE TRIGGER trg_{table}_softdel 
  BEFORE DELETE ON {table} 
  FOR EACH ROW EXECUTE FUNCTION app.soft_delete();

-- 3. Audit log
CREATE TRIGGER trg_{table}_audit 
  AFTER INSERT OR UPDATE OR DELETE ON {table} 
  FOR EACH ROW EXECUTE FUNCTION ops.log_audit();
```

---

### 9. Audit Log Eksik ğŸ”´

#### âŒ YANLIÅ

```sql
-- Audit log yok!
UPDATE products SET price = 100 WHERE id = $1;
-- Kim deÄŸiÅŸtirdi? Ne zamandÄ±? Eski fiyat neydi? Bilinmiyor!
```

**Sorun:**
- "Kim benim Ã¼rÃ¼nÃ¼ sildi?" â†’ Bilmiyorum
- GDPR/KVKK compliance yok
- Debug impossible
- Yasal sorun

#### âœ… DOÄRU

```sql
-- Audit log trigger
CREATE TRIGGER trg_products_audit 
  AFTER INSERT OR UPDATE OR DELETE ON products 
  FOR EACH ROW EXECUTE FUNCTION ops.log_audit();
```

**Audit Log Function:**

```sql
CREATE OR REPLACE FUNCTION ops.log_audit()
RETURNS trigger LANGUAGE plpgsql AS $$
DECLARE 
  v_tenant int := app.current_tenant();
  v_user   int := app.current_user_id();
BEGIN
  INSERT INTO ops.audit_logs(
    tenant_id, user_id, action, entity_type, entity_id, 
    old_values, new_values
  )
  VALUES (
    v_tenant, v_user, TG_OP::text, TG_TABLE_NAME, 
    CASE WHEN TG_OP='INSERT' THEN NEW.id::text ELSE OLD.id::text END,
    CASE WHEN TG_OP='UPDATE' OR TG_OP='DELETE' THEN to_jsonb(OLD) END,
    CASE WHEN TG_OP='INSERT' OR TG_OP='UPDATE' THEN to_jsonb(NEW) END
  );
  RETURN COALESCE(NEW, OLD);
END$$;
```

**Audit Log KullanÄ±mÄ±:**

```sql
-- Kim Ã¼rÃ¼nÃ¼ sildi?
SELECT user_id, old_values->>'name', deleted_at 
FROM ops.audit_logs 
WHERE entity_type = 'products' AND action = 'DELETE';

-- Fiyat deÄŸiÅŸikliÄŸi geÃ§miÅŸi
SELECT 
  user_id,
  old_values->>'price' AS old_price,
  new_values->>'price' AS new_price,
  created_at
FROM ops.audit_logs 
WHERE entity_type = 'products' AND entity_id = '123' AND action = 'UPDATE';
```

**GerÃ§ek Senaryo:**
```
Hack oldu, veritabanÄ±nda deÄŸiÅŸiklikler yapÄ±ldÄ±.
Audit log yoktu, "kim ne yaptÄ±" bilinmiyordu.
Yasal sorun, mÃ¼ÅŸteri gÃ¼veni kaybÄ±.
Audit log olsaydÄ±: Her deÄŸiÅŸiklik kayÄ±t altÄ±nda.
```

---

## GerÃ§ek Projelerden Ã–ÄŸrenilen Dersler

### Ders 1: tenant_id Sonradan Eklemek

**Durum:**
- Startup 100K kullanÄ±cÄ±yla bÃ¼yÃ¼dÃ¼
- Multi-tenant olmaya karar verdi

**Sorun:**
- `tenant_id` yoktu
- 500+ tablo, 100M+ kayÄ±t
- Herbir tabloya `tenant_id` eklemek gerekti

**Migration SÃ¼reci:**
```
1. GÃ¼n: Schema tasarÄ±mÄ±
2-7. GÃ¼n: Migration script'leri
8-90. GÃ¼n: Tablolara kolum ekleme (48 saat downtime)
91-120. GÃ¼n: Data migration
121+. GÃ¼n: Testing, bug fixes
```

**SonuÃ§:**
- âŒ 3 ay migration
- âŒ 48 saat production down
- âŒ MÃ¼ÅŸteri kaybÄ± (%15)
- âŒ $500K maliyet

**Ã‡Ã¶zÃ¼m:**
- âœ… BaÅŸtan `tenant_id` ekle
- âœ… Maliyet: $0
- âœ… SÃ¼re: 0 gÃ¼n

---

### Ders 2: Email Verification Sonradan

**Durum:**
- 1M kullanÄ±cÄ± var
- Email verification yok
- Spam hesaplar var

**Sorun:**
- `email_verified` column'u sonradan eklemek kolay
- Ama mevcut 1M kullanÄ±cÄ±yÄ± nasÄ±l verify edeceksin?

**SeÃ§enekler:**
```
A) Herkesi force verify et â†’ GÃ¼vensiz
B) Herkese email gÃ¶nder â†’ Spam olarak iÅŸaretlenir
C) Login'de force verify â†’ KullanÄ±cÄ±lar sinirli
```

**SonuÃ§:**
- âŒ 6 ay sÃ¼rdÃ¼
- âŒ MÃ¼ÅŸteri ÅŸikayetleri
- âŒ Spam score arttÄ±

**Ã‡Ã¶zÃ¼m:**
- âœ… BaÅŸtan `email_verified` ekle
- âœ… Signup flow'da email verification

---

### Ders 3: Audit Logs Yok

**Durum:**
- E-ticaret sitesi hack oldu
- VeritabanÄ±nda deÄŸiÅŸiklikler yapÄ±ldÄ±
- "Kim ne yaptÄ±" bilinmiyor

**Sorun:**
- Audit log yoktu
- Hangi veriler deÄŸiÅŸti?
- Kim yaptÄ±?
- Ne zaman?

**SonuÃ§:**
- âŒ Yasal sorun (GDPR)
- âŒ MÃ¼ÅŸteri gÃ¼veni kaybÄ±
- âŒ Data recovery impossible
- âŒ $2M ceza

**Ã‡Ã¶zÃ¼m:**
- âœ… BaÅŸtan audit logs kur
- âœ… Her deÄŸiÅŸiklik kayÄ±t altÄ±nda
- âœ… GDPR/KVKK compliance

---

### Ders 4: Currency Sonradan

**Durum:**
- ABD merkezli SaaS
- TÃ¼rkiye'ye expand ettiler
- TÃ¼m fiyatlar USD

**Sorun:**
- GeÃ§miÅŸ sipariÅŸler hangi kurdan?
- TRY'ye nasÄ±l Ã§evireceksin?
- Exchange rate geÃ§miÅŸi yok

**Migration:**
```sql
-- Her tabloda price var:
ALTER TABLE products ADD COLUMN currency VARCHAR(3) DEFAULT 'USD';
ALTER TABLE orders ADD COLUMN currency VARCHAR(3) DEFAULT 'USD';
ALTER TABLE subscriptions ADD COLUMN currency VARCHAR(3) DEFAULT 'USD';
-- 50+ tablo...

-- GeÃ§miÅŸ kurlarÄ± nereden bulacaksÄ±n?
-- 2020'de USD/TRY = 7.50 muydu, 8.00 mÄ±ydÄ±?
```

**SonuÃ§:**
- âŒ 2 ay migration
- âŒ GeÃ§miÅŸ veriler yanlÄ±ÅŸ
- âŒ Muhasebe kaos

**Ã‡Ã¶zÃ¼m:**
- âœ… BaÅŸtan multi-currency kur
- âœ… `cfg.currencies` + `cfg.exchange_rates`
- âœ… GeÃ§miÅŸ kurlar kayÄ±t altÄ±nda

---

## BaÅŸarÄ± Kriterleri

Bu checklist'e uyarak sistemi kurduÄŸunda:

| Kriter | SonuÃ§ |
|--------|-------|
| **Ã–lÃ§eklenebilirlik** | 10 â†’ 10,000 tenant (kolay) |
| **Debug** | Audit logs sayesinde her ÅŸey izlenebilir |
| **GÃ¼venlik** | RLS, 2FA, API scopes, rate limiting hazÄ±r |
| **Global** | i18n/l10n, multi-currency hazÄ±r |
| **Faturalama** | Usage tracking, subscriptions hazÄ±r |
| **Yasal Uyumluluk** | GDPR, KVKK - audit logs var |
| **Performans** | Index'ler, partitioning hazÄ±r |
| **GÃ¼venilirlik** | Soft delete, backups, history |

---

## 3 AltÄ±n Kural

### 1. BAÅTAN DOÄRU KUR

```
âœ… tenant_id HERYERDE
âœ… RLS aktif
âœ… TIMESTAMPTZ (timezone aware)
âœ… Indexes
âœ… Triggers
âœ… Audit logs
```

**Neden:**
- Sonradan eklemek 10x daha zor
- Migration 48 saat downtime
- MÃ¼ÅŸteri kaybÄ± riski

### 2. SONRADAN EKLENEMEYECEKLERÄ° UNUT

```
âŒ Multi-tenancy
âŒ Timezone
âŒ Currency
âŒ Soft delete
âŒ Email verification
```

**Neden:**
- 1M kayÄ±tta migration = felaket
- GeÃ§miÅŸ veriler = kayÄ±p
- Production down = para kaybÄ±

### 3. CHECKLIST'Ä° TAKÄ°P ET

```
ğŸ”´ P0 â†’ MUTLAKA BAÅTAN
ğŸŸ¡ P1 â†’ Ä°LK HAFTA
ğŸŸ¢ P2 â†’ Ä°LK AY
```

**Neden:**
- Sistematik yaklaÅŸÄ±m
- HiÃ§bir ÅŸey unutulmaz
- BaÅŸarÄ± garantili

---

## âŒ Checklist'e UymazsanÄ±z

```
1. Sistem hÄ±zlÄ± bÃ¼yÃ¼r
2. Migration gerekir
3. 48 saat downtime
4. MÃ¼ÅŸteriler kÄ±zgÄ±n
5. Para kaybÄ±
6. Reputation zarar gÃ¶rÃ¼r
7. Yasal sorunlar
```

## âœ… Checklist'e UyarsanÄ±z

```
1. Sistem doÄŸru kurulu
2. 10M kullanÄ±cÄ±ya scale eder
3. Zero downtime
4. Mutlu mÃ¼ÅŸteriler
5. HÄ±zlÄ± bÃ¼yÃ¼me
6. Kolay maintenance
7. Yasal uyumluluk
```

---

## ğŸ”— Ä°lgili DÃ¶kÃ¼manlar

- [09_Implementation_Checklist.md](09_Implementation_Checklist.md) - P0/P1/P2 features
- [12_Table_Template.md](12_Table_Template.md) - DoÄŸru tablo template'i
- [04_RLS_Multi_Tenant_Strategy.md](04_RLS_Multi_Tenant_Strategy.md) - RLS implementation

---

**Versiyon:** 1.0.0  
**Tarih:** Ekim 2025  
**Yazar:** HZM Development Team

---

**[â—€ï¸ Geri: Implementation Checklist](09_Implementation_Checklist.md) | [Ana Sayfa](README.md) | [Ä°leri: Roadmap & Tech Stack â–¶ï¸](11_Roadmap_TechStack.md)**

