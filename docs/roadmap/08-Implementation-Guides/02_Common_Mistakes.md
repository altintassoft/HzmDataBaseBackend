# 🚨 Common Mistakes

> **9 kritik hata & çözümleri - Gerçek projelerden öğrenilen dersler**

[◀️ Geri: Implementation Checklist](09_Implementation_Checklist.md) | [Ana Sayfa](README.md) | [İleri: Roadmap & Tech Stack ▶️](11_Roadmap_TechStack.md)

---

## 📋 İçindekiler

1. [9 Kritik Hata](#9-kritik-hata)
2. [Gerçek Projelerden Öğrenilen Dersler](#gerçek-projelerden-öğrenilen-dersler)
3. [Başarı Kriterleri](#başarı-kriterleri)
4. [3 Altın Kural](#3-altın-kural)

---

## 9 Kritik Hata

### 1. RLS Yok (En Kritik Hata!) 🔴

#### ❌ YANLIŞ

```sql
CREATE TABLE products (
  id SERIAL PRIMARY KEY,
  tenant_id INTEGER NOT NULL,
  name VARCHAR(200)
);

-- Developer kodu:
SELECT * FROM products WHERE tenant_id = $1;  -- Developer'a bağlı!
```

**Sorun:**
- Developer unutursa `WHERE tenant_id = $1` → Tüm tenant'ların verileri leak olur!
- SQL injection risk
- Junior developer hata yapabilir

#### ✅ DOĞRU

```sql
CREATE TABLE products (
  id GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tenant_id INTEGER NOT NULL REFERENCES core.tenants(id),
  name VARCHAR(200)
);

-- RLS aktif et
ALTER TABLE products ENABLE ROW LEVEL SECURITY;

-- RLS policy
CREATE POLICY rls_products_tenant ON products
  USING (tenant_id = app.current_tenant())
  WITH CHECK (tenant_id = app.current_tenant());

-- Developer kodu:
SELECT * FROM products;  -- RLS otomatik tenant_id = X ekler!
```

**Çözüm:**
- ✅ Database-level güvenlik
- ✅ Unutulması imkansız
- ✅ Her query'de otomatik çalışır

**Gerçek Senaryo:**
```
Bir SaaS şirketi RLS kullanmıyordu. 
Junior developer WHERE tenant_id = $1 yazmayı unuttu.
1 tenant'ın verileri tüm tenant'lara gitti.
Yasal dava, $2M ceza.
```

---

### 2. tenant_id Eksik 🔴

#### ❌ YANLIŞ

```sql
CREATE TABLE products (
  id SERIAL PRIMARY KEY,
  name VARCHAR(200),
  price DECIMAL(10,2)
);
```

**Sorun:**
- Multi-tenant yapı yok
- Sonradan eklemek 48 saat migration
- 1M kayıtta production down

#### ✅ DOĞRU

```sql
CREATE TABLE products (
  id GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  tenant_id INTEGER NOT NULL REFERENCES core.tenants(id),  -- 🔥 MUTLAKA!
  name VARCHAR(200),
  price DECIMAL(10,2)
);

-- Index
CREATE INDEX idx_products_tenant ON products(tenant_id);
```

**Çözüm:**
- ✅ Her tabloda `tenant_id`
- ✅ Her query'de `WHERE tenant_id = X`
- ✅ Index ile performans

**Gerçek Senaryo:**
```
Startup 100K kullanıcıyla büyüdü.
Multi-tenant olmaya karar verdi.
3 ay migration, müşteri kaybı, $500K maliyet.
```

---

### 3. SERIAL yerine GENERATED BY DEFAULT AS IDENTITY 🟡

#### ❌ YANLIŞ (Eski PostgreSQL)

```sql
id SERIAL PRIMARY KEY
```

**Sorun:**
- Eski syntax (PostgreSQL 9.x)
- Sequence ownership karmaşık
- Modern PostgreSQL desteği yok

#### ✅ DOĞRU (Modern PostgreSQL 10+)

```sql
id GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY  -- 🔥
```

**Farklar:**

| Özellik | SERIAL | IDENTITY |
|---------|--------|----------|
| PostgreSQL | 7.x+ | 10+ |
| Standard SQL | ❌ | ✅ |
| Sequence ownership | Manual | Otomatik |
| TRUNCATE ... RESTART | ⚠️ Complex | ✅ Kolay |
| Explicit insert | ✅ İzin verir | ✅ İzin verir |

**Örnek:**

```sql
-- SERIAL
CREATE TABLE users (id SERIAL PRIMARY KEY);
-- Arka planda: CREATE SEQUENCE users_id_seq; ALTER TABLE users ALTER id SET DEFAULT nextval('users_id_seq');

-- IDENTITY
CREATE TABLE users (id GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY);
-- SQL Standard, daha temiz!
```

---

### 4. VARCHAR yerine citext (email için) 🟡

#### ❌ YANLIŞ

```sql
email VARCHAR(255) UNIQUE NOT NULL
```

**Sorun:**
- `user@test.com` ≠ `USER@TEST.COM`
- Aynı email 2 defa kayıt olabilir
- Duplicate user accounts

#### ✅ DOĞRU

```sql
email citext UNIQUE NOT NULL  -- 🔥 Case-insensitive!
```

**Fark:**

```sql
-- VARCHAR ile:
SELECT * FROM users WHERE email = 'user@test.com';  -- 1 sonuç
SELECT * FROM users WHERE email = 'USER@TEST.COM';  -- 0 sonuç

-- citext ile:
SELECT * FROM users WHERE email = 'user@test.com';  -- 1 sonuç
SELECT * FROM users WHERE email = 'USER@TEST.COM';  -- 1 sonuç (aynı!)
```

**Gerçek Senaryo:**
```
E-ticaret sitesi VARCHAR kullanıyordu.
Kullanıcı user@test.com ile kayıt oldu.
Sonra USER@TEST.COM ile tekrar kayıt oldu.
2 hesap, 1 email → support nightmare.
```

---

### 5. TIMESTAMP yerine TIMESTAMPTZ 🔴

#### ❌ YANLIŞ

```sql
created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
```

**Sorun:**
- Timezone bilgisi yok!
- Yurtdışı expansion'da sorun
- DST (Daylight Saving Time) bug'ları

#### ✅ DOĞRU

```sql
created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP  -- 🔥
```

**Fark:**

```sql
-- TIMESTAMP (timezone yok)
INSERT INTO logs (created_at) VALUES ('2025-01-15 10:00:00');
-- Hangi timezone? New York? Tokyo? Bilinmiyor!

-- TIMESTAMPTZ (timezone var)
INSERT INTO logs (created_at) VALUES ('2025-01-15 10:00:00+03');
-- Kesin: İstanbul zamanı!
```

**Örnek Senaryo:**

```
ABD'de kurulan startup Türkiye'ye expand etti.
TIMESTAMP kullanıyorlar.
created_at = '2025-01-15 10:00:00'  -- Hangi timezone?
3 saat fark support tickets'da kaos.
```

---

### 6. Soft Delete Eksik 🔴

#### ❌ YANLIŞ

```sql
DELETE FROM products WHERE id = $1;
-- Veri gitti, geri gelmez!
```

**Sorun:**
- Kazara silme → veri kaybı
- "Yanlış sildim, geri getirebilir misin?" → Hayır!
- GDPR/KVKK compliance yok

#### ✅ DOĞRU

```sql
-- Soft delete columns
is_deleted BOOLEAN DEFAULT FALSE,
deleted_at TIMESTAMPTZ,
deleted_by INTEGER,

-- Soft delete trigger
CREATE TRIGGER trg_products_softdel 
  BEFORE DELETE ON products 
  FOR EACH ROW EXECUTE FUNCTION app.soft_delete();

-- Developer kodu:
DELETE FROM products WHERE id = $1;  -- Trigger otomatik UPDATE'e çevirir!
```

**Soft Delete Function:**

```sql
CREATE OR REPLACE FUNCTION app.soft_delete()
RETURNS trigger LANGUAGE plpgsql AS $$
DECLARE 
  v_user int := app.current_user_id();
BEGIN
  EXECUTE format(
    'UPDATE %I.%I SET is_deleted = true, deleted_at = now(), deleted_by = $1 WHERE id = $2',
    TG_TABLE_SCHEMA, TG_TABLE_NAME
  ) USING v_user, OLD.id;
  RETURN NULL;  -- Cancel physical delete
END$$;
```

**Gerçek Senaryo:**
```
E-ticaret sitesi 10K ürünü yanlışlıkla sildi.
Backup yoktu.
24 saat süren data recovery, müşteri kaybı.
Soft delete olsaydı: 1 dakikada geri getirirlerdi.
```

---

### 7. Index Eksik 🟡

#### ❌ YANLIŞ

```sql
-- Index yok!
SELECT * FROM products WHERE tenant_id = $1;  -- Full table scan! (Yavaş!)
```

**Sorun:**
- 1M kayıtta her query saniyeler alır
- Production'da timeout
- CPU %100

#### ✅ DOĞRU

```sql
-- Index ekle
CREATE INDEX idx_products_tenant ON products(tenant_id);  -- 🔥

-- Artık hızlı:
SELECT * FROM products WHERE tenant_id = $1;  -- Index scan (Milliseconds!)
```

**Hangi Index'ler Zorunlu:**

```sql
-- 1. tenant_id (her tabloda!)
CREATE INDEX idx_{table}_tenant ON {table}(tenant_id);

-- 2. Foreign keys
CREATE INDEX idx_{table}_{fk} ON {table}(user_id);

-- 3. Sık aranan kolonlar
CREATE INDEX idx_{table}_active ON {table}(tenant_id) 
  WHERE is_active = TRUE AND is_deleted = FALSE;

-- 4. Composite index (birlikte arananlar)
CREATE INDEX idx_{table}_composite ON {table}(tenant_id, status, created_at);
```

**Performans Farkı:**

```
-- Index yok: 1M kayıt, 5.2 saniye
-- Index var:  1M kayıt, 12 millisecond

426x daha hızlı!
```

---

### 8. Trigger'lar Eksik 🟡

#### ❌ YANLIŞ

```sql
-- Her UPDATE'te manuel updated_at:
UPDATE products 
SET name = 'New Name', updated_at = now(), version = version + 1 
WHERE id = $1;

-- Developer unutabilir!
```

**Sorun:**
- `updated_at` unutulursa yanlış timestamp
- `version` unutulursa race condition
- Manuel = error-prone

#### ✅ DOĞRU

```sql
-- Trigger ekle
CREATE TRIGGER trg_products_touch 
  BEFORE UPDATE ON products 
  FOR EACH ROW EXECUTE FUNCTION app.touch_row();

-- Developer kodu:
UPDATE products SET name = 'New Name' WHERE id = $1;
-- updated_at ve version otomatik artar!
```

**Touch Row Function:**

```sql
CREATE OR REPLACE FUNCTION app.touch_row()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  NEW.updated_at := now();
  IF TG_OP = 'UPDATE' THEN
    NEW.version := COALESCE(OLD.version, 1) + 1;  -- Optimistic locking
  END IF;
  RETURN NEW;
END$$;
```

**Standard 3 Trigger:**

```sql
-- 1. Updated_at + version
CREATE TRIGGER trg_{table}_touch 
  BEFORE UPDATE ON {table} 
  FOR EACH ROW EXECUTE FUNCTION app.touch_row();

-- 2. Soft delete
CREATE TRIGGER trg_{table}_softdel 
  BEFORE DELETE ON {table} 
  FOR EACH ROW EXECUTE FUNCTION app.soft_delete();

-- 3. Audit log
CREATE TRIGGER trg_{table}_audit 
  AFTER INSERT OR UPDATE OR DELETE ON {table} 
  FOR EACH ROW EXECUTE FUNCTION ops.log_audit();
```

---

### 9. Audit Log Eksik 🔴

#### ❌ YANLIŞ

```sql
-- Audit log yok!
UPDATE products SET price = 100 WHERE id = $1;
-- Kim değiştirdi? Ne zamandı? Eski fiyat neydi? Bilinmiyor!
```

**Sorun:**
- "Kim benim ürünü sildi?" → Bilmiyorum
- GDPR/KVKK compliance yok
- Debug impossible
- Yasal sorun

#### ✅ DOĞRU

```sql
-- Audit log trigger
CREATE TRIGGER trg_products_audit 
  AFTER INSERT OR UPDATE OR DELETE ON products 
  FOR EACH ROW EXECUTE FUNCTION ops.log_audit();
```

**Audit Log Function:**

```sql
CREATE OR REPLACE FUNCTION ops.log_audit()
RETURNS trigger LANGUAGE plpgsql AS $$
DECLARE 
  v_tenant int := app.current_tenant();
  v_user   int := app.current_user_id();
BEGIN
  INSERT INTO ops.audit_logs(
    tenant_id, user_id, action, entity_type, entity_id, 
    old_values, new_values
  )
  VALUES (
    v_tenant, v_user, TG_OP::text, TG_TABLE_NAME, 
    CASE WHEN TG_OP='INSERT' THEN NEW.id::text ELSE OLD.id::text END,
    CASE WHEN TG_OP='UPDATE' OR TG_OP='DELETE' THEN to_jsonb(OLD) END,
    CASE WHEN TG_OP='INSERT' OR TG_OP='UPDATE' THEN to_jsonb(NEW) END
  );
  RETURN COALESCE(NEW, OLD);
END$$;
```

**Audit Log Kullanımı:**

```sql
-- Kim ürünü sildi?
SELECT user_id, old_values->>'name', deleted_at 
FROM ops.audit_logs 
WHERE entity_type = 'products' AND action = 'DELETE';

-- Fiyat değişikliği geçmişi
SELECT 
  user_id,
  old_values->>'price' AS old_price,
  new_values->>'price' AS new_price,
  created_at
FROM ops.audit_logs 
WHERE entity_type = 'products' AND entity_id = '123' AND action = 'UPDATE';
```

**Gerçek Senaryo:**
```
Hack oldu, veritabanında değişiklikler yapıldı.
Audit log yoktu, "kim ne yaptı" bilinmiyordu.
Yasal sorun, müşteri güveni kaybı.
Audit log olsaydı: Her değişiklik kayıt altında.
```

---

## Gerçek Projelerden Öğrenilen Dersler

### Ders 1: tenant_id Sonradan Eklemek

**Durum:**
- Startup 100K kullanıcıyla büyüdü
- Multi-tenant olmaya karar verdi

**Sorun:**
- `tenant_id` yoktu
- 500+ tablo, 100M+ kayıt
- Herbir tabloya `tenant_id` eklemek gerekti

**Migration Süreci:**
```
1. Gün: Schema tasarımı
2-7. Gün: Migration script'leri
8-90. Gün: Tablolara kolum ekleme (48 saat downtime)
91-120. Gün: Data migration
121+. Gün: Testing, bug fixes
```

**Sonuç:**
- ❌ 3 ay migration
- ❌ 48 saat production down
- ❌ Müşteri kaybı (%15)
- ❌ $500K maliyet

**Çözüm:**
- ✅ Baştan `tenant_id` ekle
- ✅ Maliyet: $0
- ✅ Süre: 0 gün

---

### Ders 2: Email Verification Sonradan

**Durum:**
- 1M kullanıcı var
- Email verification yok
- Spam hesaplar var

**Sorun:**
- `email_verified` column'u sonradan eklemek kolay
- Ama mevcut 1M kullanıcıyı nasıl verify edeceksin?

**Seçenekler:**
```
A) Herkesi force verify et → Güvensiz
B) Herkese email gönder → Spam olarak işaretlenir
C) Login'de force verify → Kullanıcılar sinirli
```

**Sonuç:**
- ❌ 6 ay sürdü
- ❌ Müşteri şikayetleri
- ❌ Spam score arttı

**Çözüm:**
- ✅ Baştan `email_verified` ekle
- ✅ Signup flow'da email verification

---

### Ders 3: Audit Logs Yok

**Durum:**
- E-ticaret sitesi hack oldu
- Veritabanında değişiklikler yapıldı
- "Kim ne yaptı" bilinmiyor

**Sorun:**
- Audit log yoktu
- Hangi veriler değişti?
- Kim yaptı?
- Ne zaman?

**Sonuç:**
- ❌ Yasal sorun (GDPR)
- ❌ Müşteri güveni kaybı
- ❌ Data recovery impossible
- ❌ $2M ceza

**Çözüm:**
- ✅ Baştan audit logs kur
- ✅ Her değişiklik kayıt altında
- ✅ GDPR/KVKK compliance

---

### Ders 4: Currency Sonradan

**Durum:**
- ABD merkezli SaaS
- Türkiye'ye expand ettiler
- Tüm fiyatlar USD

**Sorun:**
- Geçmiş siparişler hangi kurdan?
- TRY'ye nasıl çevireceksin?
- Exchange rate geçmişi yok

**Migration:**
```sql
-- Her tabloda price var:
ALTER TABLE products ADD COLUMN currency VARCHAR(3) DEFAULT 'USD';
ALTER TABLE orders ADD COLUMN currency VARCHAR(3) DEFAULT 'USD';
ALTER TABLE subscriptions ADD COLUMN currency VARCHAR(3) DEFAULT 'USD';
-- 50+ tablo...

-- Geçmiş kurları nereden bulacaksın?
-- 2020'de USD/TRY = 7.50 muydu, 8.00 mıydı?
```

**Sonuç:**
- ❌ 2 ay migration
- ❌ Geçmiş veriler yanlış
- ❌ Muhasebe kaos

**Çözüm:**
- ✅ Baştan multi-currency kur
- ✅ `cfg.currencies` + `cfg.exchange_rates`
- ✅ Geçmiş kurlar kayıt altında

---

## Başarı Kriterleri

Bu checklist'e uyarak sistemi kurduğunda:

| Kriter | Sonuç |
|--------|-------|
| **Ölçeklenebilirlik** | 10 → 10,000 tenant (kolay) |
| **Debug** | Audit logs sayesinde her şey izlenebilir |
| **Güvenlik** | RLS, 2FA, API scopes, rate limiting hazır |
| **Global** | i18n/l10n, multi-currency hazır |
| **Faturalama** | Usage tracking, subscriptions hazır |
| **Yasal Uyumluluk** | GDPR, KVKK - audit logs var |
| **Performans** | Index'ler, partitioning hazır |
| **Güvenilirlik** | Soft delete, backups, history |

---

## 3 Altın Kural

### 1. BAŞTAN DOĞRU KUR

```
✅ tenant_id HERYERDE
✅ RLS aktif
✅ TIMESTAMPTZ (timezone aware)
✅ Indexes
✅ Triggers
✅ Audit logs
```

**Neden:**
- Sonradan eklemek 10x daha zor
- Migration 48 saat downtime
- Müşteri kaybı riski

### 2. SONRADAN EKLENEMEYECEKLERİ UNUT

```
❌ Multi-tenancy
❌ Timezone
❌ Currency
❌ Soft delete
❌ Email verification
```

**Neden:**
- 1M kayıtta migration = felaket
- Geçmiş veriler = kayıp
- Production down = para kaybı

### 3. CHECKLIST'İ TAKİP ET

```
🔴 P0 → MUTLAKA BAŞTAN
🟡 P1 → İLK HAFTA
🟢 P2 → İLK AY
```

**Neden:**
- Sistematik yaklaşım
- Hiçbir şey unutulmaz
- Başarı garantili

---

## ❌ Checklist'e Uymazsanız

```
1. Sistem hızlı büyür
2. Migration gerekir
3. 48 saat downtime
4. Müşteriler kızgın
5. Para kaybı
6. Reputation zarar görür
7. Yasal sorunlar
```

## ✅ Checklist'e Uyarsanız

```
1. Sistem doğru kurulu
2. 10M kullanıcıya scale eder
3. Zero downtime
4. Mutlu müşteriler
5. Hızlı büyüme
6. Kolay maintenance
7. Yasal uyumluluk
```

---

## 🔗 İlgili Dökümanlar

- [09_Implementation_Checklist.md](09_Implementation_Checklist.md) - P0/P1/P2 features
- [12_Table_Template.md](12_Table_Template.md) - Doğru tablo template'i
- [04_RLS_Multi_Tenant_Strategy.md](04_RLS_Multi_Tenant_Strategy.md) - RLS implementation

---

**Versiyon:** 1.0.0  
**Tarih:** Ekim 2025  
**Yazar:** HZM Development Team

---

**[◀️ Geri: Implementation Checklist](09_Implementation_Checklist.md) | [Ana Sayfa](README.md) | [İleri: Roadmap & Tech Stack ▶️](11_Roadmap_TechStack.md)**

